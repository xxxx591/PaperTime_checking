package com.tocheck.parent.core.utils;

import com.thoughtworks.xstream.XStream;
import com.thoughtworks.xstream.core.util.QuickWriter;
import com.thoughtworks.xstream.io.HierarchicalStreamWriter;
import com.thoughtworks.xstream.io.xml.PrettyPrintWriter;
import com.thoughtworks.xstream.io.xml.XmlFriendlyNameCoder;
import com.thoughtworks.xstream.io.xml.XppDriver;
import com.tocheck.parent.common.constans.Constants;
import com.tocheck.parent.common.dto.ChargeForm;
import com.tocheck.parent.common.dto.WeiXinPayDto;
import com.tocheck.parent.common.util.*;
import com.tocheck.parent.core.properties.PayProperties;
import org.apache.commons.lang3.StringUtils;
import org.dom4j.Document;
import org.dom4j.Element;
import org.dom4j.io.SAXReader;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Component;

import javax.servlet.http.HttpServletRequest;
import java.io.*;
import java.text.DecimalFormat;
import java.util.*;

/**
 * @author pangliang
 * @create 2017-04-19 13:48
 **/
@Component
public class WxPayUtil {


    private static final Logger logger = LoggerFactory.getLogger(WxPayUtil.class);

    @Autowired
    private PayProperties payProperties;

    @Autowired
    private RechargeOrderUtil rechargeOrderUtil;


    public ResponseJson createWxOrder(ChargeForm chargeForm) throws Exception {
        if (rechargeOrderUtil.getByOrderNum(chargeForm.getOrderNum()) == null) {
            rechargeOrderUtil.create(chargeForm);
        }
        Map<String, String> map = new LinkedHashMap<>();
        List<String> list = new LinkedList<>();
        WeiXinPayDto weiXinPayDto = new WeiXinPayDto();
        list.add("appid");
        map.put("appid", payProperties.wxAppId);
        weiXinPayDto.setAppid(payProperties.wxAppId);
        list.add("mch_id");
        map.put("mch_id", payProperties.wxMchId);
        weiXinPayDto.setMch_id(payProperties.wxMchId);
        list.add("device_info");
        map.put("device_info", "WEB");
        weiXinPayDto.setDevice_info("WEB");
        list.add("nonce_str");
        String nonceStr = rechargeOrderUtil.createNonceStr();
        map.put("nonce_str", nonceStr);
        weiXinPayDto.setNonce_str(nonceStr);
        list.add("body");
        map.put("body", chargeForm.getSubject());
        weiXinPayDto.setBody(chargeForm.getSubject());
//        list.add("attach");
//        map.put("attach", chargeForm.getUserId() + "");
//        weiXinPayDto.setAttach(chargeForm.getUserId() + "");
        list.add("out_trade_no");
        map.put("out_trade_no", chargeForm.getOrderNum());
        weiXinPayDto.setOut_trade_no(chargeForm.getOrderNum());
        list.add("total_fee");
//        DecimalFormat df = new DecimalFormat("#0");
//        String totalAmount = df.format(chargeForm.getAmount().doubleValue() * 100);
        String totalAmount = "1";
        map.put("total_fee", totalAmount);
        weiXinPayDto.setTotal_fee(totalAmount);
        list.add("spbill_create_ip");
        map.put("spbill_create_ip", chargeForm.getUserIp());
        weiXinPayDto.setSpbill_create_ip(chargeForm.getUserIp());
        list.add("time_start");
        String startTime = DateUtil.getDate(new Date(), "yyyyMMddHHmmss");
        map.put("time_start", startTime);
        Calendar calendar = Calendar.getInstance();
        calendar.add(Calendar.MINUTE, 10);
        weiXinPayDto.setTime_start(startTime);
        list.add("time_expire");
        String endTime = DateUtil.getDate(calendar.getTime(), "yyyyMMddHHmmss");
        map.put("time_expire", endTime);
        weiXinPayDto.setTime_expire(endTime);
        list.add("notify_url");
        map.put("notify_url", payProperties.wxNotifyUrl);
        weiXinPayDto.setNotify_url(payProperties.wxNotifyUrl);
        list.add("trade_type");
        map.put("trade_type", payProperties.wxTradeType);
        weiXinPayDto.setTrade_type(payProperties.wxTradeType);
        list.add("product_id");
        map.put("product_id", payProperties.wxProductId);
        weiXinPayDto.setProduct_id(payProperties.wxProductId);
        list.add("limit_pay");
        map.put("limit_pay", payProperties.wxLimitPay);
        weiXinPayDto.setLimit_pay(payProperties.wxLimitPay);
        String sign = weiPaySign(map, list, payProperties.wxApiKey);
        map.put("sign", sign);
        weiXinPayDto.setSign(sign);
        xstream.alias("xml", WeiXinPayDto.class);
        String params = xstream.toXML(weiXinPayDto);
        params = StringUtils.replace(params, "__", "_");
        logger.info("支付请求参数params={}", params);
        String resultStr = HttpClientUtil.doHttpPost(payProperties.wxGateway, params);
        logger.info("支付结果resultStr={}", resultStr);
        InputStream inputStream = new ByteArrayInputStream(resultStr.getBytes("UTF-8"));
        Map<String, String> payMap = parseXml(inputStream);
        String code_url = payMap.get("code_url");
        Map<String, Object> result = new HashMap<>();
        if (StringUtils.isNoneBlank(code_url)) {
            String path = DateUtil.getDate(new Date(), "yyyyMMdd/HH/mm/");
            String qrUrl = QrCodeUtil.createQrCode(code_url, payProperties.wxQrCodePath + path, chargeForm.getOrderNum());
            result.put("url", payProperties.wxQrCodeUrl + path + qrUrl);
            result.put("orderNum", chargeForm.getOrderNum());
            result.put("amount", chargeForm.getAmount());
            return ResponseJson.body(Constants.RESP_SUCCESS, "1", result);
        } else {
            return ResponseJson.body(Constants.RESP_FAIL, "生成支付二维码失败,请刷新后重试或联系客服!");
        }
    }

    public SortedMap<String, String> parseXmlToMap(InputStream inputStream) throws Exception {
        // 将解析结果存储在HashMap中
        SortedMap<String, String> map = new TreeMap<>();
        // 从request中取得输入流
        // 读取输入流
        SAXReader reader = new SAXReader();
        Document document = reader.read(inputStream);
        // 得到xml根元素
        Element root = document.getRootElement();
        // 得到根元素的所有子节点
        List<Element> elementList = root.elements();
        // 遍历所有子节点
        for (Element e : elementList)
            map.put(e.getName(), e.getText());
        // 释放资源
        inputStream.close();
        return map;
    }

    public boolean wxNotify(SortedMap<String, String> paramsMap) throws IOException {
        //签名拼接，需要去掉返回的签名串字段sign
        if (isTencentPaySign(paramsMap)) {
            //通过微信支付签名检验
            logger.info("当前支付请求校验通过returnCode={},returnCode={},", paramsMap.get("result_code"), paramsMap.get("return_code"));
            if (StringUtils.equals("SUCCESS", paramsMap.get("return_code")) && StringUtils.equals("SUCCESS", paramsMap.get("result_code"))) {
                //支付成功
                String orderNum = paramsMap.get("out_trade_no");
                String tradeNum = paramsMap.get("transaction_id");
                Double totalFee = Double.valueOf(paramsMap.get("total_fee")) / 100;
                DecimalFormat df = new DecimalFormat("#0.00");
                String totalFeeStr = df.format(totalFee);
                return rechargeOrderUtil.updateRechargeStatus(orderNum, tradeNum, totalFeeStr);
            }
        } else {
            logger.warn("微信支付签名校验失败!");
        }
        return false;
    }

    public boolean isTencentPaySign(SortedMap<String, String> parameters) {
        StringBuffer sb = new StringBuffer();
        Set es = parameters.entrySet();
        Iterator it = es.iterator();
        while (it.hasNext()) {
            Map.Entry entry = (Map.Entry) it.next();
            String key = (String) entry.getKey();
            String value = (String) entry.getValue();
            if (!"sign".equals(key) && null != key && !"".equals(key)) {
                sb.append(key + "=" + value + "&");
            }
            logger.info("当前参数信息name={},value={}", key, value);
        }

        sb.append("key=" + payProperties.wxApiKey);
        String sign = MD5Utils.getMD5StringUtf8(sb.toString()).toUpperCase();
        String tenpaySign = parameters.get("sign").toUpperCase();
        return tenpaySign.equals(sign);
    }

    ////////////////////////////////////////////////微信支付////////////////////////////////////////////////////////////////////
    private String weiPaySign(Map<String, String> map, List<String> list, String wxApiKey) throws UnsupportedEncodingException {
        Collections.sort(list);
        StringBuffer params = new StringBuffer("");
        for (String param : list) {
            params.append(param).append("=").append(map.get(param)).append("&");
        }
        params.append("key=").append(wxApiKey);
        return MD5Utils.getMD5StringUtf8(params.toString()).toUpperCase();
    }

    /**
     * 扩展xstream，使其支持CDATA块
     */
    public XStream xstream = new XStream(new XppDriver(new XmlFriendlyNameCoder("__", "_")) {
        public HierarchicalStreamWriter createWriter(Writer out) {
            return new PrettyPrintWriter(out) {
                // 对所有xml节点的转换都增加CDATA标记
                boolean cdata = true;

                public void startNode(String name, Class clazz) {
                    super.startNode(name, clazz);
                }

                protected void writeText(QuickWriter writer, String text) {
                    if (cdata) {
                        writer.write("<![CDATA[");
                        writer.write(text);
                        writer.write("]]>");
                    } else {
                        writer.write(text);
                    }
                }
            };
        }
    });

    /**
     * 解析微信发来的请求（XML）
     *
     * @param inputStream
     * @return
     * @throws Exception
     */
    public Map<String, String> parseXml(InputStream inputStream) throws Exception {
        // 将解析结果存储在HashMap中
        Map<String, String> map = new HashMap<>();
        // 从request中取得输入流
        // 读取输入流
        SAXReader reader = new SAXReader();
        Document document = reader.read(inputStream);
        // 得到xml根元素
        Element root = document.getRootElement();
        // 得到根元素的所有子节点
        List<Element> elementList = root.elements();

        // 遍历所有子节点
        for (Element e : elementList)
            map.put(e.getName(), e.getText());
        // 释放资源
        inputStream.close();
        return map;
    }
}
